// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
#define UNITY_DEBUG
using System;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Collections;
using System.Collections.Generic;

#if UNITY_DEBUG
using UnityEngine;
#endif



namespace MyClient
{
	/// <summary>
	/// 异步客户端
	/// </summary>
	public class AsyncClient
	{
		#region Fields
		
		private Socket _client;
		private bool disposed = false;
		private int retries = 0;
		private bool firstConnect=true;
		private Session _session;
		#endregion
		
		#region Properties
		
		/// <summary>
		/// 是否已与服务器建立连接
		/// </summary>
		public bool Connected { get { return _client.Connected; } }
		/// <summary>
		/// 远端服务器的IP地址列表
		/// </summary>
		public IPAddress[] Addresses { get; private set; }
		/// <summary>
		/// 远端服务器的端口
		/// </summary>
		public int Port { get; private set; }
		/// <summary>
		/// 连接重试次数
		/// </summary>
		public int Retries { get; set; }
		/// <summary>
		/// 连接重试间隔
		/// </summary>
		public int RetryInterval { get; set; }
		/// <summary>
		/// 远端服务器终结点
		/// </summary>
		public IPEndPoint RemoteIPEndPoint
		{
			get { return new IPEndPoint(Addresses[0], Port); }
		}
		/// <summary>
		/// 本地客户端终结点
		/// </summary>
		protected IPEndPoint LocalIPEndPoint { get; private set; }
		/// <summary>
		/// 通信所使用的编码
		/// </summary>
		public Encoding Encoding { get; set; }

		public Session _Session {get;private set;}
		
		#endregion
		
		#region 构造函数
		
		/// <summary>
		/// 异步TCP客户端
		/// </summary>
		/// <param name="remoteEP">远端服务器终结点</param>
		public AsyncClient(IPEndPoint remoteEP)
			: this(new[] { remoteEP.Address }, remoteEP.Port)
		{
		}
		/// <summary>
		/// 异步TCP客户端
		/// </summary>
		/// <param name="remoteEP">远端服务器终结点</param>
		/// <param name="localEP">本地客户端终结点</param>
		public AsyncClient(IPEndPoint remoteEP, IPEndPoint localEP)
			: this(new[] { remoteEP.Address }, remoteEP.Port, localEP)
		{
		}
		
		/// <summary>
		/// 异步TCP客户端
		/// </summary>
		/// <param name="remoteIPAddress">远端服务器IP地址</param>
		/// <param name="remotePort">远端服务器端口</param>
		public AsyncClient(IPAddress remoteIPAddress, int remotePort)
			: this(new[] { remoteIPAddress }, remotePort)
		{
		}
		
		/// <summary>
		/// 异步TCP客户端
		/// </summary>
		/// <param name="remoteIPAddress">远端服务器IP地址</param>
		/// <param name="remotePort">远端服务器端口</param>
		/// <param name="localEP">本地客户端终结点</param>
		public AsyncClient(
			IPAddress remoteIPAddress, int remotePort, IPEndPoint localEP)
			: this(new[] { remoteIPAddress }, remotePort, localEP)
		{
		}
		
		/// <summary>
		/// 异步TCP客户端
		/// </summary>
		/// <param name="remoteHostName">远端服务器主机名</param>
		/// <param name="remotePort">远端服务器端口</param>
		public AsyncClient(string remoteHostName, int remotePort)
			: this(Dns.GetHostAddresses(remoteHostName), remotePort)
		{
		}
		
		/// <summary>
		/// 异步TCP客户端
		/// </summary>
		/// <param name="remoteHostName">远端服务器主机名</param>
		/// <param name="remotePort">远端服务器端口</param>
		/// <param name="localEP">本地客户端终结点</param>
		public AsyncClient(
			string remoteHostName, int remotePort, IPEndPoint localEP)
			: this(Dns.GetHostAddresses(remoteHostName), remotePort, localEP)
		{
		}
		
		/// <summary>
		/// 异步TCP客户端
		/// </summary>
		/// <param name="remoteIPAddresses">远端服务器IP地址列表</param>
		/// <param name="remotePort">远端服务器端口</param>
		public AsyncClient(IPAddress[] remoteIPAddresses, int remotePort)
			: this(remoteIPAddresses, remotePort, null)
		{
		}
		
		/// <summary>
		/// 异步TCP客户端
		/// </summary>
		/// <param name="remoteIPAddresses">远端服务器IP地址列表</param>
		/// <param name="remotePort">远端服务器端口</param>
		/// <param name="localEP">本地客户端终结点</param>
		public AsyncClient(
			IPAddress[] remoteIPAddresses, int remotePort, IPEndPoint localEP)
		{
			this.Addresses = remoteIPAddresses;
			this.Port = remotePort;
			this.LocalIPEndPoint = localEP;
			//this.Encoding = Encoding.Default;
			this.Encoding = Encoding.UTF8;

			if (this.LocalIPEndPoint != null)
			{
				_client = new Socket(LocalIPEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
			}
			else
			{
				_client =new Socket (AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);
			}
			_session=new Session(_client);

			Retries = 3;
			RetryInterval = 5;
		}
		
		#endregion
		
		#region Connect
		/// <summary>
		/// 连接到服务器
		/// </summary>
		/// <returns>异步TCP客户端</returns>
		public AsyncClient Connect()
		{
			if (!Connected)
			{
				firstConnect=true;
				// start the async connect operation
				_client.BeginConnect(
					Addresses, Port, HandleTcpServerConnected, _client);
			}
			
			return this;
		}
		/// <summary>
		/// 关闭与服务器的连接
		/// </summary>
		/// <returns>异步TCP客户端</returns>
		public AsyncClient Close()
		{
			if (Connected)
			{
				retries = 0;
				_client.Close();
				RaiseServerDisconnected(Addresses, Port);
			}
			
			return this;
		}
		
		#endregion
		
		#region Receive
		
		private void HandleTcpServerConnected(IAsyncResult ar)
		{
			try
			{
				_client.EndConnect(ar);
				RaiseServerConnected(Addresses, Port);
				retries = 0;
			}
			catch (Exception ex)
			{
				#if UNITY_DEBUG
				Debug.LogError(ex.Message);
				#endif
			}
			// we are connected successfully and start asyn read operation.
			_session.RecvDataBuffer = new byte[_client.ReceiveBufferSize];
			_client.BeginReceive(_session.RecvDataBuffer, 0, _session.RecvDataBuffer.Length, SocketFlags.None,
			                     new AsyncCallback(HandleDatagramReceived), _session);
		}
		
		private void HandleDatagramReceived(IAsyncResult ar)
		{
			try
			{
				int recv = _client.EndReceive(ar);
				if(recv!=0)
				{
					Session session = (Session)ar.AsyncState;
//					Buffer.BlockCopy(buffer, 0, receivedBytes, 0, recv);
					RaiseDatagramReceived( session);

					_session.ClearBuffer();
					// then start reading from the network again
					_client.BeginReceive(session.RecvDataBuffer, 0,session.RecvDataBuffer.Length, SocketFlags.None, HandleDatagramReceived, session);
				}
				else
				{
					this.Close();
				}
			}
			catch (Exception ex)
			{
				Debug.LogError(ex.Message);
			}
		}
		
		#endregion
		
		#region Events
		
		/// <summary>
		/// 接收到数据报文事件
		/// </summary>
		public event EventHandler<AsyncEventArgs> DatagramReceived;
		
		private void RaiseDatagramReceived( Session session)
		{
			if (DatagramReceived != null)
			{
				DatagramReceived(this, new AsyncEventArgs(session));
			}
		}
		
		/// <summary>
		/// 与服务器的连接已建立事件
		/// </summary>
		public event EventHandler<EventArgs> ServerConnected;
		/// <summary>
		/// 与服务器的连接已断开事件
		/// </summary>
		public event EventHandler<EventArgs> ServerDisconnected;
		/// <summary>
		/// 与服务器的连接发生异常事件
		/// </summary>
		public event EventHandler<EventArgs> ServerExceptionOccurred;
		
		private void RaiseServerConnected(IPAddress[] ipAddresses, int port)
		{
			if (ServerConnected != null)
			{
				ServerConnected(this, new EventArgs());
			}
		}
		
		private void RaiseServerDisconnected(IPAddress[] ipAddresses, int port)
		{
			if (ServerDisconnected != null)
			{
				ServerDisconnected(this, new EventArgs());
			}
		}
		
		private void RaiseServerExceptionOccurred(
			IPAddress[] ipAddresses, int port, Exception innerException)
		{
			if (ServerExceptionOccurred != null)
			{
				ServerExceptionOccurred(this, new EventArgs());
			}
		}
		
		#endregion
		
		#region Send
		
		/// <summary>
		/// 发送报文
		/// </summary>
		/// <param name="datagram">报文</param>
		public void Send(byte[] datagram)
		{
			if (datagram == null)
				throw new ArgumentNullException("datagram");
			/*Connected 属性获取截止到最后的 I/O 操作时 Socket 的连接状态。 当它返回 false 时，
			表明 Socket 要么从未连接，要么已断开连接。
			Connected 属性的值反映最近操作时的连接状态。 如果您需要确定连接的当前状态，请进行非阻止、零字节的 Send 调用。
			如果该调用成功返回或引发 WAEWOULDBLOCK 错误代码 (10035)，则该套接字仍然处于连接状态；否则，该套接字不再处于连接状态。
			如果调用用户数据报协议 (UDP) 套接字上的 Connect，则 Connected 属性始终返回 true；不过，此操作不更改 UDP 的内在无连接特性。*/
			//TODO bug!第一次发送数据时肯定是FALSE啊. 已经修改
			if (!Connected)
			{
				if(firstConnect==false)
				{
					RaiseServerDisconnected(Addresses, Port);
					throw new InvalidProgramException(
						"This client has not connected to server.");
				}

			}
			if(firstConnect==true)
			{
				Thread.Sleep(10);
				firstConnect=false;
			}
#if UNITY_DEBUG
//			Debug.Log("Send!!!");
#endif
			_client.BeginSend(datagram, 0, datagram.Length, SocketFlags.None, HandleDataSend, _client);
		}
		
		private void HandleDataSend(IAsyncResult ar)
		{
			((Socket)ar.AsyncState).EndSend(ar);
		}
		
		/// <summary>
		/// 发送报文
		/// </summary>
		/// <param name="datagram">报文</param>
		public void Send(string datagram)
		{
			Send(this.Encoding.GetBytes(datagram));
		}
		
		#endregion
		
		#region IDisposable Members
		
		/// <summary>
		/// Performs application-defined tasks associated with freeing, 
		/// releasing, or resetting unmanaged resources.
		/// </summary>
		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}
		
		/// <summary>
		/// Releases unmanaged and - optionally - managed resources
		/// </summary>
		/// <param name="disposing"><c>true</c> to release both managed 
		/// and unmanaged resources; <c>false</c> 
		/// to release only unmanaged resources.
		/// </param>
		protected virtual void Dispose(bool disposing)
		{
			if (!this.disposed)
			{
				if (disposing)
				{
					try
					{
						Close();
						
						if (_client != null)
						{
							_client = null;
						}
					}
					catch (SocketException)
					{
					}
				}
				
				disposed = true;
			}
		}
		
		#endregion



	}
}

